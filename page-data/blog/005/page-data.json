{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/005","result":{"data":{"markdownRemark":{"frontmatter":{"author":"isabel","date":"2021-11-30","title":"my top SPL (splunk) commands, functions, & features","path":"/blog/005"},"html":"<p>I use Splunk/SPL (Splunk Processing Language) nearly daily in my job and thought I'd provide a quick summary of the commands, functions, &#x26; features I use regularly to perform my searches. For full documentation/reference of Splunk search commands, visit <a href=\"https://docs.splunk.com/Documentation/Splunk/8.2.3/SearchReference/Whatsinthismanual\">this page</a>.</p>\n<h5>> commenting</h5>\n<p>First, thing's first. The most useful and empathetic language feature is the comment. In Splunk, and as of this post's publication date, you designate the start and end of a comment block with three backticks. Below, you can find the comment, \"this will only output eight attributes from the lookup,\" enclosed with backticks.</p>\n<pre><code>``` this will only output eight attributes from the lookup ```\n| inputlookup some_predefined_lookup\n| table attribute1 attribute2 attribute3 attribute4 attribute5 attribute6 attribute7 attribute8\n</code></pre>\n<h5>> resuing searches (\"savedsearch\")</h5>\n<p>Before I discovered this trick, I had ran into a problem where I had created a very long query and wanted to reuse its results a second time to append the secondary results to the first set of results. I was essentially looking for a command that would perform a \"jump\" (similar to a jump statement would work in assembly) back to the start of the long query. I also didn't want to copy over the long query because doing so would decrease legibility.</p>\n<p>The <em>savedsearch</em> command allows you to re-run a report in a new search. To solve my aforementioned issue, I found that saving the original (long) query as something like a base report and leveraging it in my \"children\" searches/reports allowed for more elegant re-use. Below is a snippet of how it is used.</p>\n<pre><code>| savedsearch base_report\n| table attribute1 attribute2 attribute3 attribute4 attribute5 attribute6 attribute7 attribute8\n</code></pre>\n<h5>> resuing searches (\"loadjob\")</h5>\n<p>The <em>loadjob</em> command performs similarly to the <em>savedsearch</em>. The difference is that the <em>loadjob</em> command does not re-run the report and instead loads cached results from a previously scheduled run of the report. This command is ideal for expensive searches. Below is a snippet of how it is used.</p>\n<pre><code>| loadjob base_report\n| table attribute1 attribute2 attribute3 attribute4 attribute5 attribute6 attribute7 attribute8\n</code></pre>\n<h5>> resuing searches (macros)</h5>\n<p>When dealing with repetitive searches, it may be better to utilize macros. In Splunk, macros behave like modular functions. You can even specify if the macro requires an input (arguments).</p>\n<p>To define a macro, you can navigate to Settings > Advanced search > Search macros, and click New Search Macro. When defining your macro, you can set additional behaviors if applicable (i.e. validation expressions, error messages, etc.). To use the macro in you searches, call the name of the macro enclosed with a single backtick on either side of it. Below is a snippet of how it is used (for this example, assume the macro takes one argument, \"attribute9,\" as input).</p>\n<pre><code>index=myindex sourcetype=dasmytype\n| `mymacro(attribute9)`\n| table attribute1 attribute2 attribute3 attribute4 attribute5 attribute6 attribute7 attribute8\n</code></pre>\n<h5>> conditional counts with stats</h5>\n<p>With large datasets, succintly counting values against a condition can be a useful trick. When outputting data with the <em>stats</em> command, instead of using two lines of SPL to enumerate data (<em>eval</em> piped to a <em>count</em>), you can combine them as nested functions.</p>\n<p>Take for example a lookup file, myfoods, containing an inventory of foods in my refridgerator. Assume the inventory is actually a large dataset and contains many attributes, but for the sake of this example, we are only interested in these attributes: food<em>name, food</em>type (our only values are \"FRUIT\" and \"VEGETABLE\"), and food_freshness (our only values are \"VERY FRESH,\" \"FRESH,\" and \"SPOILED\"). </p>\n<p>Now we want to organize the dataset to get simple statistics about these three attributes. In SPL, the top search can be re-written as the bottom search to get your desired results more succinctly:</p>\n<pre><code>| inputlookup myfoods\n| eval very_fresh_fruits = food_freshness = \"VERY FRESH\" AND food_type = \"FRUIT\"\n| eval fresh_fruits = food_freshness = \"FRESH\" AND food_type = \"FRUIT\"\n| eval spoiled_fruits = food_freshness = \"SPOILED\" AND food_type = \"FRUIT\"\n| stats count(very_fresh_fruits) as very_fresh_fruits_count, count(fresh_fruits) as fresh_fruits_count, count(spoiled_fruits) as spoiled_fruits_count\n| table food_name very_fresh_fruits fresh_fruits spoiled_fruits\n</code></pre>\n<pre><code>| inputlookup myfoods\n| stats count(food_freshness = \"VERY FRESH\" AND food_type = \"FRUIT\") as very_fresh_fruits_count, count(food_freshness = \"FRESH\" AND food_type = \"FRUIT\") as fresh_fruits_count, count(food_freshness = \"SPOILED\" AND food_type = \"FRUIT\") as spoiled_fruits_count\n| table food_name very_fresh_fruits fresh_fruits spoiled_fruits\n</code></pre>\n<h5>> reformatting similar fields</h5>\n<p>It's not uncommon when examing large datasets of logs to encounter many timestamps. Sometimes I deal with 5-10+ timestamp fields that are subject to the same data massaging techniques. Instead of applying such techniques one by one, using for-loops quickly takes care of each one without writing repetitive steps.</p>\n<p>Take for example a lookup file, mylogofmanytimestamps, containing 20 timestamp fields (for whatever reason). We want to change the format of the timestamps from one (\"%d-%m-%Y\") to another (\"%m/%d/%Y\"). For this to work, assume that each timestamp field is named so that its suffix is \"_timestamp\" - so three timestamp fields, for example, are created_timestamp, sleep_timestamp, and destroyed_timestamp.</p>\n<p>The for-loop to reformat the timestamps collectively can be written as such:</p>\n<pre><code>| inputlookup mylogofmanytimestamps\n| foreach *_timestamp\n    [ eval &#x3C;&#x3C;FIELD>> = strptime(&#x3C;&#x3C;FIELD>>, \"%m/%d/%Y\")]\n| table *\n</code></pre>\n<p>In this query, the asterisk is use to capture any permutation of characters, and &#x3C;&#x3C;FIELD>> is a placeholder for the timestamp variable used in each loop.</p>\n<h5>> appending dissimilar results</h5>\n<p>Sometimes in my reports, I like to combine multiple small searches as one. To accomplish this, I usually use the <em>appendcols</em> command.</p>\n<p>Take for example two reports, report1 and report2. Each of these reports contains unique fields that neither of them share - report1 has attribute1 and attribute2, while report2 has attribute3 and attribute4 - and I want to combine the datasets as one to enumerate attribute1, attribute2, attribute3, and attribute4. Below is a snippet of how I can accomplish this using <em>appendcols</em>.</p>\n<pre><code>| savedsearch report1\n| appendcols [| savedsearch report2 ]\n| table *\n</code></pre>\n<p>As you can imagine, you do not have to use saved searches/reports to use <em>appendcols</em>. Searches and subsearches can be used; I just used reports to demonstrate the command. The <em>append</em> command behaves similarly, except the  results are appended as a row and not a column, so they will appear below the parent search. The only warning to using <em>append</em> is that Splunk will create new columns if the parent and child searches do not already share the same attributes, and stylistically, it just does not look very nice.</p>\n<h5>> normalizing multivariate fields</h5>\n<p><em>to be continued because im lazy right now, and i want to watch Dune, but the function is mvindex()... read more in the official documentation, brb</em></p>\n<h5>> using joins</h5>\n<p><em>also to be continued because this could be a big ass section and i want to watch Dune, but read more in the offiical documentation.... brb</em></p>\n<h5>> a useless trick I learned</h5>\n<p>Sometimes when I use <em>append</em> to bring two datasets together, and I want to utilize a line break, I do the following (there's probably a more elegant way to utilize line breaks, but I'm not pressed to really discover them right now):</p>\n<pre><code>| savedsearch samplereport1\n| table attribute1 attribute2 attribute3\n| append [ search | head 1 | eval attribute1=\"------------------------------ lol ------------------------------\"]\n| table attribute1 attribute2 attribute3\n| append [|savedsearch samplereport2 | table attribute1 attribute2 attribute3 ] \n</code></pre>\n<h5>> another useless trick I learned</h5>\n<p>There was a rare time I had to show the same attribute twice (verbatim) in a single report, and Splunk does not allow that for obvious reasons (you cannot attribute two values to a single field if the record is unique). To accomplish that, I duplicated and renamed the same field using a whitespace, and reassigned the value back to the new field. It's a very weird scenario, but anyway, here is what I did:</p>\n<pre><code>index=myindex sourcetype=dasmytype\n| eval attribute1_ = attribute1, attribute1__ = attribute1\n| reanme attribute1_ as \"attribute1 \", attribute1__ as \"attribute1  \"\n| table attribute1 \"attribute1 \" \"attribute1  \"\n</code></pre>"}},"pageContext":{}},"staticQueryHashes":[]}