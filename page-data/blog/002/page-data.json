{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/002","result":{"data":{"markdownRemark":{"frontmatter":{"author":"isabel","date":"2021-08-31","title":"deploying forkbum.com, part 1","path":"/blog/002"},"html":"<p>I ran into two blockers attempting to deploy my website for the first time. The first blocker related to <strong>build errors with gatsby/react</strong>. This post details what I did to turn my code into a compiled build prior to deploying my wesite. (You can jump tomy second blocker <a href=\"https://forkbum.com/blog/003\">here</a>.)</p>\n<h5>> the problem</h5>\n<p>Whenever the site was ran in the build environment, either of these two error messages were thrown:</p>\n<pre><code>WebpackError: ReferenceError: window is not defined\n\nWebpackError: Invariant Violation: Minified React error #130.\n</code></pre>\n<p>From these error types, I first suspected webpack is complaining either about the \"window\" browser property not being able to be found and/or dependency issues when trying to create the minified production build.</p>\n<h5>> the research</h5>\n<p>Further research showed that either of these errors were thrown at path \"/\" - which is essentially <a href=\"https://forkbum.com/\">my home page</a>. In particular, it was at my unnecessarily fancy animation the home page leverages that the errors were thrown.</p>\n<p>I built this animation using <a href=\"https://github.com/Gherciu/react-p5\">react-p5</a>, a React wrapper for the p5.js library. p5.js is basically JavaScript's answer to Java's <a href=\"https://processing.org/\">Processing</a>, providing the programmer tools to build simulations and graphics in their projects.</p>\n<p>Because p5.js is a visual library, it utilizes the browser window; many of the library's variables, such as windowWidth, map to browser properties. windowWidth, for instance, maps to window.innerWidth, which is width of the browser window's content area in pixels.</p>\n<p>When running the site in the development server, these errors are not thrown because those browser properties (i.e. window) work well in the development environment, thus making them available to gatsby. When running the site in the build environment, however, files are bundled using webpack in node runtime, and it freaks out when those browser properties can't be found. This situation becomes more probable when using third-party libraries like react-p5.</p>\n<h5>> the solution</h5>\n<p>To fix these issues, I attempted two things.... First, I followed guidance from <a href=\"https://www.gatsbyjs.com/docs/debugging-html-builds/#how-to-check-if-window-is-defined\">gatsby documentation</a> itself and added the following code to my gatsby-node.js file - making sure to replace \"bad-module\" with \"react-p5\":</p>\n<pre><code>exports.onCreateWebpackConfig = ({ stage, loaders, actions }) => {\n  if (stage === \"build-html\" || stage === \"develop-html\") {\n    actions.setWebpackConfig({\n      module: {\n        rules: [\n          {\n            test: /bad-module/,\n            use: loaders.null(),\n          },\n        ],\n      },\n    })\n  }\n}\n</code></pre>\n<p>In this code, we are customizing our webpack configuration by writing a rule to find the \"bad module\" (written as the regular expression literal) and replacing it with a null loader during server-side rendering.</p>\n<p>Welp... for whatever reason this fixed the \"window\" ReferenceError but introduced a new error, the Invariant Violation error. Apparently this was happening because webpack was trying to minify those relevant files, but the imports were pointing to null because of the code we had just added to gatsby-node.js.</p>\n<p><em>The second solution was then to re-write my component to utilize dynamic loading of react-p5.</em></p>\n<p>Programmatically, my home page calls a component which contains my react-p5 code. To implement this second solution, I basically re-wrote this component as a class-based component instead of as a functional component to make use of <a href=\"https://projects.wojtekmaj.pl/react-lifecycle-methods-diagram/\">lifecycle methods</a> - specifically render() during component mounting into the DOM.</p>\n<p>I also installed <a href=\"https://loadable-components.com/docs/getting-started/\">@loadable/component</a>, which helps to render that dynamic loading. Then, I stuck all my original code in a truth check to check if the window browser property is defined.</p>\n<p>By the end, I had basically re-written my code to something like this:</p>\n<pre><code>import loadable from '@loadable/component'\n\nclass myComponent extends React.Component {\n    render() {\n        if (typeof window !== 'undefined') {\n            const myComponent = loadable(() => import('bad-module'));\n            //my code\n        } else {\n            return null;\n        }\n    }\n}\n</code></pre>\n<p>After making these changes, my errors were resolved, and I no longer had any build errors pertaining to my third-party libraries and the window property.</p>"}},"pageContext":{}},"staticQueryHashes":[]}