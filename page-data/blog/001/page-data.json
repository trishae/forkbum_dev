{"componentChunkName":"component---src-templates-blog-template-js","path":"/blog/001","result":{"data":{"markdownRemark":{"frontmatter":{"author":"isabel","date":"2021-01-01","title":"recap of a recent ctf I competed in","path":"/blog/001"},"html":"<p>About a few months ago, I entered a CTF hosted by my company. There were approximately 70 registrants, and I placed 11th by the end of the competition as a team by myself. There were various categories to choose problems from - coding, exploitation, forensics, cryptography, and more.</p>\n<p>This post is just to summarize the techniques and approaches for only a subset of the problems I solved, mostly because these are the ones I either remember or have the best written evidence for (i.e. code).</p>\n<h4>problem a: QR codes</h4>\n<p>In this problem, a .zip file was provided containing 5,000 .png files of QR codes. The flag was hidden somwhere in these QR codes.</p>\n<p>My first thought was to loop through each of these .png files and use a library to decode the code. Below is my modified Python code which uses the <a href=\"https://pypi.org/project/zbarlight/\">zbarlight library</a> for decoding. (Note: I code in unoptimized fashion when competing heh).</p>\n<pre><code>import os\nfrom PIL import Image\nimport zbarlight\n\ndef main():\n    directory = './../../data/qrcodes'\n\n    walk(directory)\n\ndef walk(directory):\n    for filename in os.listdir(directory):\n        if filename.endswith(\".png\"):\n            print('processing... ', os.path.join(directory, filename))\n            find(os.path.join(directory, filename))\n            continue\n        else:\n            continue\n\ndef find(filename):\n    with open(filename, 'rb') as imagefile:\n        image = Image.open(imagefile)\n        image.load()\n\n    codes = zbarlight.scan_codes(['qrcode'], image)\n    print('QR codes: %s' % codes)\n\nmain()\n</code></pre>\n<p>This was a fairly straightforward problem for me. The most challenging part was getting the dependencies to be compatible. I remember facing a lot of issues with getting the right version of the PIL library. Furthermore, the code can be optimized my implementing a loop such that if the condition that a regular expression matches the flag is met, break out of the loop.</p>\n<h4>problem b: socket programming</h4>\n<p>In this problem, I was to connect to a server, solve an arithmetic expression, then brute force a four digit PIN to get the flag. I was also provided with this command-line snippet: nc [redacted server name] [port]</p>\n<p>Although provided, solving this doesn't require using netcat. This requires socket programming (using Python, the socket library does the job). </p>\n<p>In a try-catch-finally block, I established a connection to the server and received a response to prove I am human by solving an arithmetic expression, which is random at any given connection. To solve this expression, I used the eval() function in Python, which can accept the whole addition, subtraction, multiplication, or division-related expression as the parameter. The answer is then sent as a reponse, and if correct, the server then sends back the challenge to provide the pin. Since this can only be solved via brute force, this enitre server-client conversation is put inside a loop, such that for every iteration of the loop, the pin also iterates by 1. So for the first attempt, the pin is 0000, and if it is incorrect, iterate the pin to 0001 and re-establish the connection to the server. The loop goes on until 9999 or until the challenge is solved. Below is my modified Python code.</p>\n<pre><code>import socket\npin = 0\n\ndef compute(expression):\n    return str(eval(expression))\n\ndef ask(pin):\n    server = # server name here\n    port = # port here\n\n    flag_msg = ''\n\n    try:\n        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        s.connect((server, port))\n\n        arithmetic_msg = s.recv(1024).decode('utf-8')\n        print(arithmetic_msg)\n\n        ans_reply = compute(arithmetic_msg.split(': ', maxsplit=1)[1].split(' =')[0]) + '\\n'\n        print(ans_reply, ans_reply.encode())\n\n        s.sendall(ans_reply.encode())\n\n        pin_msg = s.recv(1024).decode('utf-8')\n        print(pin_msg)\n\n        pin_reply = str(pin).zfill(4) + '\\n'\n\n        s.sendall(pin_reply.encode())\n        print('trying...', pin_reply)\n\n        flag_msg = s.recv(1024).decode('utf-8')\n        print(flag_msg)\n\n    except (BrokenPipeError, ConnectionResetError):\n        print('error caught')\n    finally:\n        s.close()\n\ndef main(pin):\n    while pin &#x3C; 10000:\n        print('----- round', pin, '-----')\n        ask(pin)\n        pin = pin + 1\n\nmain(pin)\n</code></pre>\n<p>This code can be optimized to break out of the loop when the flag is received as well.</p>\n<h4>problem c: hashed passwords</h4>\n<p>In this problem, I was to figure out the password of a user who says the password is the concatenation of two consecutive words in Rick Astley's \"Never Gonna Give You Up\" and an exclamation mark, such that the first letter of each word is capitalized. The shadow and passwd files are provided. In the shadow file, we can see the password entry for the user.</p>\n<p>The shadow file contains key clues about our password. The grouping after the first colon contain the hashed password, the salt, and the hashing algorithm itself (for detailed information about the shadow file, see <a href=\"https://linux-audit.com/password-security-with-linux-etc-shadow-file/\">this site</a>). We know that the plaintext password is hashed using SHA-512 with the provided salt.</p>\n<p>The solution for this problem requires brute force. Essentially, we want to step through every two consecutive words of the lyrics, hash it using SHA-512 with the salt, and see if it matches the hashed password in the shadow file. See below for the code in Python.</p>\n<pre><code>from passlib.hash import sha512_crypt\n\ndef main():\n    filename = './../../data/rickPassword/nevergonnagiveyouup'\n    salt = '8KWIs3JF'\n\n    read(filename, salt)\n\ndef read(filename, salt):\n    with open(filename) as file:\n        data = file.read().split()\n\n    for i in range(0,len(data)-1):\n        password = data[i].capitalize() + data[i+1].capitalize() + '!'\n        hashedpassword = sha512_crypt.encrypt(password, salt=salt, rounds=5000)\n        print('word: ', password, '/ hashed password: ', hashedpassword)\n        isShadowPassword(hashedpassword)\n\ndef isShadowPassword(hashedpassword):\n    shadow = '$6$8KWIs3JF$IH9LkPx5uhxpZ3eHN.aADCK3K/p/X/1VAnLA3KURxXy7kg1tYUpu/jz/ujtgqstHyNLlf/XftUG0SFF49Qkip1'\n    if hashedpassword == shadow:\n        print('match found')\n\nmain()\n</code></pre>\n<h4>problem d: java decompiling</h4>\n<p>This problem is a bit complex to explain, so I will just speak on the tool I used to approach  it. Basically, I am only provided a .jar file, and once de-compiled, the Java code must be ran, which then launches a program requiring a code to be entered during runtime. This code is essentially the flag.</p>\n<p>To de-compile the .jar file, I used JD-GUI. It's a pretty straightforward tool - the only issues that arised for me was correcting reformats and dependency errors caused by the decompile. More on the tool can be found <a href=\"http://java-decompiler.github.io/\">here</a>. </p>\n<p>After extracting the source code, the code can then be re-compiled and ran. In the source code, the user input is applied an encryption (XOR) alogrithm then checked against the correct encrypted code.</p>\n<h4>problem e: exploitation</h4>\n<p>Section under revision still :(</p>"}},"pageContext":{}},"staticQueryHashes":[]}